---
title: 효율적인 리눅스 명령어 사용의 기술
author: 김준회
date: 2023-11-14 23:00:00 +0900
categories: [TIL, 리눅스]
tags: [TIL, 리눅스]
pin: true
math: true
mermaid: true
image:
  path: /commons/today-i-learned.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt:
---
아래 내용들은 [책](https://m.yes24.com/Goods/Detail/123878910)을 보고 학습 목적으로 작성한 것임!

[평](https://brunch.co.kr/@topasvga/3581)이 상당히 좋다.
# 핵심 개념

## 리눅스 명령 결합하기
자기 완결적인 애플리케이션 하나를 사용하는 방식 말고도, 작은 프로그램 여러개를 조합하여 사용하는 경우가 있죠. 커맨드 라인 세계에서 이는 `파이프`를 통해서 확인해 볼 수 있습니다. 
### 입출력 및 파이프
운영체제가 입력 및 출력할 때는 스트림을 통해서 하며, 기본 스트림은 stdin, stdout (standard in, standard out) 스트림을 사용합니다. 애플리케이션들은 스트림을 통해 데이터를 입력받거나 출력합니다. 

**`파이프(|)` 기호는 왼쪽의 명령을 오른쪽의 애플리케이션의 입력 스트림으로 전달하라는 의미입니다.**

`ls -l | less` 이라는 명령은 현재 경로의 파일 리스트를 출력하여 이를 `less`라는 한 페이지단위로 출력하는 프로그램의 입력 스트림으로 전달하라는 명령어입니다. 이런 식으로 명령들이 결합됩니다.

### 기본 명령
가장 기본적인 명령들을 알아보고 갑시다.
우선 대부분의 명령어들은 `man [명령어]`로 매뉴얼을 확인할 수 있습니다.
* `man [명령어]` 와 같이 사용 방법을 가정한 문장을 Synopsis라고 합니다.
  * 사용자가 입력할 부분은 보통 대괄호(square brackets
) `[]` 으로 감싸는 방법으로 표현합니다.
* 에디터를 나오려면 q 를 입력하세요 (quit)
  * 참고: 에디터 설명을 보려면 h를 입력하면 됩니다.

---

`wc` – word, line, character, and byte count
* 줄을 바꿔주는 것도 하나의 문자인데, 이 또한 카운팅됩니다.
* wc는 출력 스트림이 무엇인지에 따라 다른 데이터를 출력하도록 설계됐습니다.
  * 한 줄에 한 파일/경로만 나타내면 줄이 너무 길어지기 때문입니다.
    * 이것은 ls | cat 으로 확인해볼 수 있습니다.
  
---

`head` – display first lines of a file
* 언제?: 출력이 너무 길 것으로 예상될 때 씁니다.
* 출력 라인수나 바이트 수를 옵션을 줘서 제어할 수 있습니다.

---

`cut` – cut out selected portions of each line of a file
* 데이터에서 특정 열만을 출력한다. 
  * delimiter가 있는 경우 (탭이나 공백 등)
  * 각 라인의 특정 바이트마다 출력하는 것도 가능하다.

---

`grep`

---

`sort`

## 쉘과 친해지기
Shell은 쉘이라고도 불리고 셸이라고도 불린다. 커맨드 라인을 처리할 수 있는 유저인터페이스를 쉘이라고 부른다.

쉘도 하는 일이 있다. bash나 zsh 에서 하는 일은 뭘까?
`*` 은 보통 **이 자리에 무엇이든 와도 됨**이라는 의미로 쓰인다.
근데 이건 프로그램에서 처리하는 게 아니다. 이건 쉘이 처리한다. 컨텍스트에 맞춰 쉘이 처리한 결과(명령어)를 실행하는 것이다.
`|` 파이프의 처리, `>`, `<` 리다이렉트의 처리 모두 쉘의 역할입니다.

사용자에게 있어 쉘은 하나의 인스턴스인데, 사람들은 꼭 그렇게만 단어를 쓰진 않는다.

### Pattern Matching (패턴 매칭)
asterisk 혹은 question mark와 같이 패턴 매칭에 사용되는 문자들은 쉘이 처리한다.
리눅스 기준으로 asterisk(`*`) 는 그 자리가 **비거나**, 아주 많은 글자여도 된다.
리눅스 기준으로 question mark(`?`) 는 기호의 개수와 일치하는 문자만 된다.

스퀘어브래킷`[]` 으로 조건이 걸린 패턴 매칭을 하는 경우도 그것을 쉘이 처리한다.
스퀘어브래킷을 사용하는 방법은 다양하다.
* `[12345]` 는 1 또는 2 또는 3 또는 4 또는 5가 그 자리에 들어갈 수 있다.
* `[1-5]` 는 1이상 5이하의 문자가 들어갈 수 있다.
* `[02468]` 은 그 자리가 짝수인 경우만 된다.
* `[A-Z]` 대문자 하나를 의미한다. (대소문자를 구분한다.)

이렇게 패턴으로 명령하는 경우는, 파일명이나 디렉터리를 입력할 경우가 대부분이다.
**왜? 어떤 조건에 맞는 파일이나 디렉터리 여러개를 명령어에 아규먼트로 주기 위함이다.**
다시 한번 주의! 패턴 매칭은 프로그램이 아니라 쉘에서 처리한다.
이것을 강조하는 이유는, 이 사실을 모를 때 명령의 오류 원인을 잘못 찾게 되는 경우가 많아서입니다.
다만 grep이나 sed, awk 같은 명령들은 자체적인 패턴 매칭 기능을 갖고 있기도 합니다.

### 변수 값의 평가
환경변수를 정의하고, 변수에 값을 저장하거나 가져오는 것도 쉘입니다.
HOME, JAVA_HOME, USER 같은 것들이 대표적인 변수입니다.
변수의 값을 보려면 `printenv [변수명]` 으로 보거나,
`echo $[변수명]` 같이 $를 붙여 변수라고 알려준 것을 출력(echo) 하면 됩니다.
(echo는 인수로 받은 값을 그대로 출력합니다. 그 이름인 메아리가 아주 잘 어울리는 프로그램입니다.)

여기서 쉘의 역할을 이해하는지 차이가 발생합니다.
echo는 변수 값을 알아오는데 아무런 일을 하지 않습니다.
변수의 값을 알아오는 것은 쉘입니다.ㅊㅇ

### 별명
별명(alias)과 변수(variable)은 무슨 차이가 있을까요.
변수는 값에 대한 이름입니다.
별명은 명령에 대해 다른 이름을 붙여주는 것입니다.

별명은 `alias [별명]=[명령]` 으로 짓습니다.
`alias g=grep`, `alias ll=ls -al` 등으로 짓는 것이 예시입니다.
참고로 별명은 명령보다 우선순위가 높습니다. 그래서 명령어와 동일한 별명을 지으면, 그 명령어는 가려진 상태가 된다고 말합니다.
설정한 별명은 `unalias [별명]` 명령으로 지울 수 있습니다.

### Redirect
입력이나 출력을 파일로 연결하려면, 리다이렉트를 하면 된다.
```bash
ls -al > listResult
echo ---result end--- >> listResult
cat listResult
cut -b1-3 <listResult
```
`>` 으로 파일로 리다이렉트할 수 있습니다.
`>>`으로 기존 파일의 끝에 내용을 추가하는 리다이렉트를 할 수 있습니다.
`<`으로 입력을 파일로 리다이렉트 할 수 있습니다.

참고로 위처럼 앵글브라켓`< >`을 이용하는 것은 기본 스트림을 대상으로 합니다.
에러 스트림은 `2>` `2>>` 등으로 명시해줘야 해당 스트림을 파일로 리다이렉트 할 수 있습니다.
표준 출력 스트림과 표준 오류 스트림을 모두 리다이렉트하려면 `&>` 을 쓰면 됩니다.

### 이스케이프
쉘이 인풋을 처리할 때 일반적으로 공백을 이용해 단어를 구분하는데,
공백이 문자열의 일부로 처리되어야 하는 경우가 있습니다.
전체 문자열을 `'`, `"` (싱글/더블 쿼테이션) 으로 감싸거나 `\ `처럼 백슬래시를 앞에 붙여주면 됩니다.
정해진 약속대로 해석하지 말고 그냥 문자 값 그대로 쓰려고 할 때, 혹은 다른 특정 문자를 표현하려고 할 때 이스케이프 문자를 씁니다.
다른 프로그래밍 언어들과 유사하게 쉘 프로그래밍에서도 백슬래시가 이스케이프 문자로 쓰입니다.

추가로, 명령의 맨 마지막에 \ 를 입력한 경우엔 그 명령이 아직 끝나지 않고 더 입력받는다는 의미로 쓰입니다.

### PATH 찾기
쉘에서 cat, ls, grep, nano 같은 명령어들은 그 실행 파일들의 목록들이 path 변수에 저장되어 있다. 이 목록을 `search path(검색 경로)`라고 한다.
명령이 입력되면 쉘은 검색 경로에서 이 명령이 있는지를 찾는다.
윈도우에서는 환경 변수가 이 역할을 합니다.
참고로 검색 경로에서 해당하는 명령이 있는지를 검색할 때는 `which`라는 명령이 사용됩니다.
내가 사용하는 명령이 어떤 프로그램으로 실행되는지 궁금하면 `which [명령어]`로 확인해 볼 수 있습니다.
유사한 명령어로 `type`도 있습니다.
쉘은 마법처럼 명령을 찾는 게 아니라, 메모리에 올라와있는 search directory에서 아주 빠르게 입력받은 명령을 찾습니다.


### 쉘의 환경
Shell의 search directory, Working directory, Prefered Editor 등의 정보는 변수에 담깁니다. 이런 정보들을 쉘의 환경(environment)라고 합니다. 환경은 쉘이 종료되면 제거됩니다.
매번 환경을 정의하기는 귀찮으니 쉘의 시작시 어떤 파일의 정보를 기준으로 환경을 구성하도록 합니다. 이러한 초기화용 파일은 보통 초기시작경로에서 `.쉘이름rc` 라는 형태로, 쉘이름+resource 라는 의미의 파일로 저장됩니다. 앞에 .은 숨김 파일을 나타냅니다.

이 리소스 파일을 쉘이 시작할 때 그 텍스트들이 명령으로 실행됩니다. 그래서 환경을 구성할 때는 이 리소스 파일을 수정해주면 됩니다.
리소스 파일은 다른 쉘 스크립트와 다를 것이 없습니다. 매번 쉘 시작시 실행된다는 것을 빼면요. 초기화 파일을 적용하는 것을 `sourcing`이라고 합니다.
`source [쉘스크립트파일명]` 이라는 명령어를 적용해주거나 쉘을 다시 시작해줘야 리소스파일의 명령들이 실행됩니다. 리소스 파일의 변경을 쉘이 감시하고 있지는 않거든요.







### 
## 실행했던 명령을 다시 실행하기
## 파일 시스템을 자유롭게 이동하기
