---
title: (Day11) - 가장 기초적인 문법에 대해서
author: 김준회
date: 2023-11-28 23:00:00 +0900
categories: [TIL, 비트캠프]
tags: [TIL, Web, 비트캠프, 네이버클라우드]
pin: true
math: true
mermaid: true
image:
  path: /commons/today-i-learned.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt:
---

> 이 글은 제가 교육을 수강하며 기록하고 추가한 내용입니다.
> **강사님과 무관하게** 잘못된 내용이 있을 수 있습니다.
{: .prompt-warning}

---

# 클라우드 기반 웹 데브옵스 프로젝트 개발자 교육 과정 (5기)

* 비트캠프 엄진영 강사님 (https://github.com/eomjinyoung/)
* 훈련기관 : 네이버클라우드주식회사
* 기간: 2023-11-14 ~ 2024-5-22
* 남은 일자 : ***118*** 일 ( 11/129 )

# 11일(2023-11-28,화)

## 기초 문법 소개: 리터럴, 변수, 연산자, 조건문, 반복문
CPU에게 명령을 내리기 위해 필요한 것은 기계어다. 그런데 기계어는 너무 어렵다. 어셈블리도 너무 어렵다. 어려울 뿐만 아니라 CPU마다도 다르다!!


![개같은"이 욕이 되어버린 이유 (요물 취급받던 고양이가 인기있는 이유)](https://t1.daumcdn.net/cfile/tistory/2436FE33596A3AAA28)

그래서 고급 언어를 만들었다!!
CPU마다 언어를 새로 익히지 않아도 된다.
몇 백개의 기계어 명령어가 필요한 경우도 고급언어는 몇 줄이면 가능할 수 있다.
너무너무 힘드니까 문제를 해결했다. 

그러한 고급언어가 한 두개가 아니다.  아주 많다.
하지만 너무 걱정하지는 말기를.. 고급언어 하나를 배우면 다른 언어도 유사한 점이 많다.
그게 기초 문법이다. 고급 언어는 다양한 종류가 있지만 이 기초문법은 대부분이 유사하다.

그 기초 문법이 `리터럴, 변수, 연산자, 조건문, 반복문`에 대한 문법이다.
하나하나 알아보자.

프로그래밍을 한다는 건 결국 소스 코드를 작성한다는 것이고,
소스 코드는 아래 사진처럼 텍스트가 나열된 것이다.

![Coding for SEO 101: Understanding source code, compressed code and compiled  code](https://searchengineland.com/wp-content/seloads/2020/03/code-SS_634574354-1920x1080-1.jpg)

`무엇을 어떻게 하라` 라는 의미의 텍스트도 있겠지만, 우선 `숫자, 글자`들은 알아야지 뭘 할 수 있지 않겠나? 그런 `숫자, 글자` 와 같은 것들을 소스코드 안에 (글자 그대로) 적는 방법이 리터럴 문법이다. (글자 그대로 들어간 값들이라고 해서 리터럴(Literal)이라고 부른다.)

프로그래밍에서 "리터럴(literal)"은 소스 코드에서 직접 나타난 고정된 값 또는 데이터를 나타냅니다. 리터럴은 변수나 상수에 할당되기 전에 사용되는 값으로, 그 자체로 고정된 값을 나타냅니다.

컴퓨터 과학의 기초를 배우면 정수나 부동소수점, 문자를 어떻게 이진수로 나타내는지를 배운다. 그게 리터럴을 속깊이 이해하기 위한 첫 걸음이다.


| 리터럴 유형   | 예시                 | 설명                                        |
|---------------|----------------------|---------------------------------------------|
| 정수 리터럴    | `42`, `0xFF`, `052`, `0b01` | 10진수, 16진수, 8진수, 2진수 정수 값          |
| 부동소수점 리터럴 | `3.14`, `2.0e3`     | 부동소수점을 나타내는 값                    |
| 불리언 리터럴  | `true`, `false`      | 참(True) 또는 거짓(False)                  |
| 문자 리터럴    | `'A'`, `'9'`         | 단일 문자를 나타내는 값                    |
| 문자열 리터럴  | `"Hello, World!"`   | 문자들의 시퀀스를 나타내는 값              |
| 널 리터럴      | `null`               | 참조 변수가 아무 객체도 참조하지 않음을 나타냄 |

이렇게 뭔가를 글자 그대로 표현할 수 있게 되면, 이것에 **이름을 붙이고 싶어진다**. (인간은 추상화를 하고, 상상을 하는 동물이다.) 
![Psychological Impact of Changing Your Name](https://vakilsearch.com/blog/wp-content/uploads/2022/04/Change-the-name.jpg)

이름을 붙이는 건 대단한 발전이다. 정보 교환이 경제적으로 이뤄진다.
 `모르는 것`에 $x$라는 이름을 붙이니 방정식의 차원으로 인류가 진화하지 않았는가.
 그것이 프로그래밍에서는 `변수`이다.
 근데 값을 표현하는 방법이 다양해서 변수는 어떤 종류의 값을 표현했는지에 따라 변수의 종류도 언급해주어야 한다. 그것이 변수의 데이터타입이다.

| 데이터 타입  | 예시 리터럴         | 설명                                                      |
|--------------|----------------------|-----------------------------------------------------------|
| `int`        | `42`, `-123`         | 정수를 나타내는 32비트 부호 있는 정수 데이터 타입         |
| `long`       | `42L`, `-123L`       | 정수를 나타내는 64비트 부호 있는 정수 데이터 타입         |
| `float`      | `3.14f`, `-0.5f`     | 부동소수점을 나타내는 32비트 부동소수점 데이터 타입       |
| `double`     | `3.14`, `-0.5`       | 부동소수점을 나타내는 64비트 부동소수점 데이터 타입       |
| `char`       | `'A'`, `'9'`, `'\n'` | 단일 문자를 나타내는 16비트 유니코드 문자 데이터 타입   |
| `boolean`    | `true`, `false`      | 논리 값 `true` 또는 `false`를 나타내는 데이터 타입       |
| `String`     | `"Hello"`, `"42"`    | 문자열을 나타내는 데이터 타입                               |
| `null`       | `null`               | 참조 변수가 아무 객체도 참조하지 않음을 나타내는 데이터 타입 |


## 연산자 사용법(com.eomcs.lang.ex05)(1)

## 조건 연산자 사용법

## 문장(statement)과 표현식(expression)의 관계

## 증감 연산자 사용법: 전위 연산자, 후위 연산자

## 연산자 우선순위

### `괄증덧곱 쉬관등비 논조대` 를 아예 외우자.
괄호 ( )
증감 (++ --)
덧셈 뺄셈 (+ -)
곱셈 나눗셈 (*, /)
쉬프트 (비트 쉬프트 >>, <<, >>>)
관계 (>, >=, <, <=)
등가 (!=, ==)
비트 (& ^ |)
논리 (&& ||)
조건 (삼항 조건 연산자 ? : )
대입 (=)


## 대입연산자 사용법: +=, -=, *=, /=, %= 등

대입연산자는 프로그래밍을 하다보니 `자주 발생하는 일`이 있어서 고안됐다.

`자주 발생하는 일`이 뭔가? 
이미 알고 있는 어떤 것에다가 추가로 연산을 하나만 하는 일이 많다는 것이다.
```
int a = 1;
a = a + 2;
a = a + 3;
```
그래서 자기 자신에게 연산을 하는 경우를 줄여 표현하는 연산자를 만들었다.
위와 아래 코드는 완전히 동일한 의미다.
```
int a = 1;
a += 2;
a += 3;
```


## 아침복습

지금까지 리터럴, 변수, 상수, 연산자까지를 배웠다.
이제부터 프로그램을 만들 수 있게 됐다.
수영으로 치면 벽 잡고 킥 차고, 판 잡고 킥 차는 과정은 얼마나 지루한가. 원래 기초는 지루한 법이다. 그러나 운동도 체력과 순발력 등 기초 훈련에서 얻을 수 있는 능력치가 가장 중요하다.

그러니까 기초 복습을 해보자. 

코드 블럭과 변수의 관계 
: 코드 블럭은 변수의 사용 범위를 설정해준다. 코드 블럭을 벗어나면 실제로 변수가 메모리에서 삭제된다. (이건 인스턴스와 달리 GC를 거치는 게 아니다.)

- [ ] 문자열로 작성된 값을 해당 타입으로 변환하는 방법을 아는가?
- [ ] 산술 연산자의 종류와 각각의 사용법을 설명할 수 있는가?
- [ ]  연산자의 우선순위는 어떻게 되는가?
- [ ] 산술 연산의 기본단위는?
- [ ] 서로 다른 데이터 타입간 연산결과로 생성되는 값의 타입은?
- [ ] 암시적 형변환은 언제 일어나는가? 왜 그렇게 설계되었을까?
- [ ] 명시적 형변환은 언제 필요한가?
- [ ] 명시적 형변환은 왜 불편하게 암시적 형변환을 허용하지 않을까? (무엇을 주의해야 할까?)
- [ ] 부동소수점 관계 연산자로 비교할 때 발생할 수 있는 문제점과 해결 방법은?
- [ ] 논리 연산자의 종류와 사용법은?
- [ ] 논리 연산자 &&, &, ||, | 의 차이점은 무엇인가?
- [ ] 비트 연산자의 종류와 사용법을 사용할 수 있는가?
- [ ] 비트 연산자 &, |를 응용해 할 수 있는 작업들을 설명할 수 있는가?
- [ ] 비트 이동 연산자의 종류와 사용법을 설명할 수 있는가?
- [ ] 비트 이동 연산자를 응용해 할 수 있는 작업들을 설명할 수 있는가?
 
### 다른 이야기
> 손흥민은 아버지에게 훈련을 받았는데, 재미있는 경기 위주, 슛 위주로 훈련을 받은 게 아니라 지겨울 정도로 패스와 드리블 훈련만 받았다고 한다. 히딩크도 국대들 데리고 기초체력 훈련만 겁나게 시켰다고 한다. 기초가 중요하다...

## 조건 연산자
> 조건문이 아니라 조건 연산자다!

조건 연산자는 아래와 같이 사용한다.
```java
조건 ? 표현식1 : 표현식2
```
조건이 true인 경우 표현식 1을 실행한다.
조건이 false인 경우 표현식 2를 실행한다.

---

**표현식은 값을 반환(Return)하는 문장(Statement)를 말한다.**
문장은 작업을 수행시키는 명령이다.
아래의 Statements, 표현식인가 아닌가?
- [x] 200
- [x] "Hello, World"
- [x] true
- [ ] System.out.println("Hi");
- [x] Math.abs(-200);
- [x] 3*2
- [x] i = i+1
- [x] i++;
- [x] ++i;
- [ ] if( --- ) { --- }

### 결과를 ***Return*** 하는 Statement만이   ***Expression*** 이다.
---

```java
test( age > 18? "성년" , "미성년" );
       ↑
```
- test( --- ) 라는 명령 블럭은 Method라고 불린다. 다른 말로는 Function이라고도 불린다. 
	- Java에서는 주로 Method로 불린다.
	- C에서는 주로 Function 라고 불린다.

Argument
: test() Method에 전달하는 값이다.

## 증감 연산자
증감 연산자는 편의를 위해 개발된 것이다. 
: 다르게 말하면, 증감 연산자가 없어도 같은 결과를 갖는 코드를 작성할 수 있다. 
다르게 말하면, 증간 연산자가 없다면 한 문장으로 처리할 수 있는 걸 두 세 문장의 있어야 처리할 수 있다는 말이다.

증감 연산자는 값을 반환한다.
: 변수의 값이 아니라 반환된 값이 사용된다.

### 전위 증감 연산자

### 후위 증감 연산자


## 연산자의 우선순위
- 가장 늦은 것은? 할당 연산자.
- 가장 빠른 것은? 증감 연산자.

### 전위, 후위 증감 연산자를 한 변수에 동시에 사용할 수 없는 이유?
전위, 후위 증감 연산자를 수행하면 값이 반환되기 때문이다.
```java
int i = 1;
++(++i);
```
이러한 코드가 있다면 이렇게 처리된다.
`++(2)`
값에 대하여 전위, 후위 증감 연산자를 수행할 수 없으므로 사전에 컴파일 오류를 발생시킨다.

---
# 흐름 제어문에 대하여
## Flow Control 을 위한 문법들

### 암기할 것
- else 문은 ***가장 가까운 if 문*** 에 소속된다.
- switch-case 문에서 case 는 리터럴만 올 수 있다.
	- case에는 4바이트 정수값만 올 수 있다. long 안된다.
	- floating point 또한 case로 사용할 수 없다.
- Switch-Case 문은 enum을 사용하자.
	- 가독성을 높일 수 있다.
	- 상수를 활용하는 것보다 관리가 편하다.
	- 상수를 활용하는 것보다 안전한 코드 작성이 가능하다.
		- enum에서 선언된 값만 할당이 가능하기 때문이다.
- continue는 코드블럭 밖의 조건문으로 흐름을 이동시킨다.
	- 보통 반복문 코드블럭 내에서 해당 반복을 멈추고 다시 반목문의 조건문으로 보내고자 할 때 쓴다.
	- 잘못 사용하면 무한 루프에 빠질 수 있다.
	- 반복을 아예 멈춰버리려면 break. 반복문을 종료하고, 조건문이 아니라 코드블럭 밖으로 나간다.

---
### 콘솔 제어를 위한 메서드
- Scanner
: 레퍼런스 변수 생성과 인스턴스 생성
```java
Scannaer keyScan;
keyScan = new Scanner(System.in);
```
> 인건비에 대하여.. 소프트웨어 세계에서 가장 비용이 많이 나가는 것은 인건비이다. 반도체 산업은 어떤가? 고용효과가 매우 적은데 이익은 크다. 건설업도 원래는 고용효과가 높았으나 요새 다 외국인이다. 소프트웨어 개발업은 고용효과가 아주 크다. 


### 깃허브 관리
백준, 리트코드, 프로그래머스 등 알고리즘 풀이를 깃허브에 연동시켜서 잔디를 심어주세요

---
### 참고... 기계어에 대한 감 잡는 방법
저사양 CPU를 사용해보면 된다.
아두이노에 운영체제 직접 만들어서 넣어보는 것.
라즈베리파이는 완전한 PC라서 복잡함..
아두이노는 OS라고도 안부른다. 프로그램 로더라고 부른다.
시동을 걸기 위한 모터가 있듯이
프로그램, 부팅을 위한 프로그램 로더나 부트로더가 있다.
0번 메모리 주소에 OS가 있다. 
옛날 하드디스크에 0번 트랙 이상 생기면 그건 부팅용으로 못썼다.
ROM. Read Only Memory 이녀석이 컴퓨터가 켜지면 
바이오스를 로드한다.
전원이 인가되면 롬에 들어있는 프로그램이 저장장치 트랙0번부터 읽어서 메모리에 올리도록 한다. 이것은 모든 컴퓨터들의 약속이다. 그 프로그램 안에는 하드디스크를 찾고 하드디스크의 0번 트랙을 찾고 부트로더로 운영체제를 메모리에 올린다.

프로그램이 3단계로 실행된다.
롬바이오스 프로그램실행
하드디스크 0번트랙 =- 부트로더 실행
부트로더가 운영체재의 0번 프로세스를 올리고 자식 프로세스들도 올리고 한다
부트로더 활동이 끝나면 이제 운영체제의 영역이다.
CPU가 무슨 일을 먼저 하나? 롬바이오스의 프로그램(기계어)를 읽는다.